{"version":3,"file":"index.umd.js","sources":["../node_modules/@blakek/curry/dist/curry.esm.js","../node_modules/pathington/es/constants.js","../node_modules/pathington/es/utils.js","../node_modules/pathington/es/index.js","../src/is-object.ts","../src/index.ts"],"sourcesContent":["function curry(fn, arity = fn.length) {\n  return function curried(...args) {\n    if (args.length >= arity) {\n      return fn(...args.slice(0, arity));\n    }\n\n    return (...newArgs) => curried(...args, ...newArgs);\n  };\n}\nfunction curryRight(fn, arity = fn.length) {\n  return function curried(...args) {\n    if (args.length >= arity) {\n      return fn(...args.slice(0, arity).reverse());\n    }\n\n    return (...newArgs) => curried(...args, ...newArgs);\n  };\n}\n\nexport { curry, curryRight };\n","/**\n * @constant {Object} CACHE\n *\n * @property {function} clear clear the cache results\n * @property {Object} results the map of path => array results\n * @property {number} size the size of the cache\n */\nexport var CACHE = {\n  clear: function clear() {\n    CACHE.results = {};\n    CACHE.size = 0;\n  },\n  results: {},\n  size: 0\n};\n/**\n * @constant {RegExp} DOTTY_WITH_BRACKETS_SYNTAX\n */\n\nexport var DOTTY_WITH_BRACKETS_SYNTAX = /\"[^\"]+\"|`[^`]+`|'[^']+'|[^.[\\]]+/g;\n/**\n * @constant {number} MAX_CACHE_SIZE\n */\n\nexport var MAX_CACHE_SIZE = 500;\n/**\n * @constant {RegExp} NUMBER\n */\n\nexport var NUMBER = /^\\d+$/i;\n/**\n * @constant {RegExp} QUOTED_KEY\n */\n\nexport var QUOTED_KEY = /^\"[^\"]+\"|`[^`]+`|'[^']+'$/;\n/**\n * @constant {Array<string>} VALID_QUOTES\n */\n\nexport var VALID_QUOTES = /^[\"'`]{1}$/;\n/**\n * @constant {RegExp} VALID_KEY\n */\n\nexport var VALID_KEY = /^\\d+$|^[a-zA-Z_$][\\w$]+$/;\n/**\n * @constant {RegExp} WHITE_SPACE\n */\n\nexport var WHITE_SPACE = /\\s/;","// constants\nimport { CACHE, DOTTY_WITH_BRACKETS_SYNTAX, MAX_CACHE_SIZE, NUMBER, QUOTED_KEY, VALID_KEY, WHITE_SPACE } from './constants';\n/**\n * @function isNumericKey\n *\n * @description\n * is the key passed a numeric string\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key passed a numeric string\n */\n\nexport var isNumericKey = function isNumericKey(key) {\n  return !!(key && key.length) && NUMBER.test(key);\n};\n/**\n * @function isQuotedKey\n *\n * @description\n * is the key passed a quoted key\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key a quoted key\n */\n\nexport var isQuotedKey = function isQuotedKey(key) {\n  return QUOTED_KEY.test(key);\n};\n/**\n * @function map\n *\n * @description\n * map the array to a new array based on fn\n *\n * @param {Array<*>} array the array to map\n * @param {function} fn the function to call with each iteration value\n * @returns {Array<*>} the mapped array\n */\n\nexport var map = function map(array, fn) {\n  var length = array.length;\n  var mapped = [];\n\n  for (var index = 0; index < length; index++) {\n    mapped[index] = fn(array[index]);\n  }\n\n  return mapped;\n};\n/**\n * @function shouldBeInBrackets\n *\n * @description\n * should the key passed be encased in brackets when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in brackets\n */\n\nexport var shouldBeInBrackets = function shouldBeInBrackets(key) {\n  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);\n};\n/**\n * @function shouldBeInQuotes\n *\n * @description\n * should the key passed be encased in quotes when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in quotes\n */\n\nexport var shouldBeInQuotes = function shouldBeInQuotes(key) {\n  return WHITE_SPACE.test(key) || !VALID_KEY.test(key);\n};\n/**\n * @function createGetNormalizedCreateKey\n *\n * @description\n * get the normalized path string based on the quote and key passed\n *\n * @param {string} [quote=\"] the quote string to use\n * @returns {function(string, *): string}\n */\n\nexport var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {\n  return function (existingString, key) {\n    var normalizedKey = shouldBeInQuotes(key) ? \"\" + quote + key + quote : key;\n    return existingString + (shouldBeInBrackets(normalizedKey) ? \"[\" + normalizedKey + \"]\" : \".\" + normalizedKey);\n  };\n};\n/**\n * @function getNormalizedParseKey\n *\n * @description\n * get the key as a number if parseable, or as a quoted string if applicable\n *\n * @param {string} key the key to try to parse\n * @returns {number|string} the parsed key\n */\n\nexport var getNormalizedParseKey = function getNormalizedParseKey(key) {\n  var cleanKey = isQuotedKey(key) ? key.slice(1, key.length - 1) : key;\n  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;\n};\n/**\n * @function parsePath\n *\n * @description\n * parse the path, memoizing the results\n *\n * @param {string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parseStringPath = function parseStringPath(path) {\n  if (CACHE.results[path]) {\n    return CACHE.results[path];\n  }\n\n  if (CACHE.size > MAX_CACHE_SIZE) {\n    CACHE.clear();\n  }\n\n  CACHE.results[path] = path ? map(path.match(DOTTY_WITH_BRACKETS_SYNTAX), getNormalizedParseKey) : [path];\n  CACHE.size++;\n  return CACHE.results[path];\n};","// constants\nimport { VALID_QUOTES } from './constants'; // utils\n\nimport { createGetNormalizedCreateKey, getNormalizedParseKey, map, parseStringPath } from './utils';\nvar isArray = Array.isArray;\n/**\n * @function create\n *\n * @description\n * create a new path string based on the path and quote passed\n *\n * @param {Array<number|string>} path the path to convert to a string\n * @param {string} [quote=\"] the quote string to use when quoting keys\n * @returns {string} the path string\n */\n\nexport var create = function create(path, quote) {\n  if (quote === void 0) {\n    quote = '\"';\n  }\n\n  if (!isArray(path)) {\n    throw new ReferenceError('path passed must be an array');\n  }\n\n  if (!VALID_QUOTES.test(quote)) {\n    throw new SyntaxError(\"quote \" + quote + \" passed is invalid, must be \\\", `, or '.\");\n  }\n\n  var pathString = path.reduce(createGetNormalizedCreateKey(quote), '');\n  return pathString[0] === '.' ? pathString.slice(1) : pathString;\n};\n/**\n * @function parse\n *\n * @description\n * the path parsed into a valid array of keys / indices\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parse = function parse(path) {\n  if (typeof path === 'string') {\n    return parseStringPath(path);\n  }\n\n  if (isArray(path)) {\n    return map(path, getNormalizedParseKey);\n  }\n\n  var normalizedParseKey = getNormalizedParseKey(path);\n  return [typeof normalizedParseKey === 'number' ? normalizedParseKey : \"\" + normalizedParseKey];\n};","export function isObject(object: any): boolean {\n  if (object === null) return false;\n\n  const type = typeof object;\n  return type === 'object' || type === 'function';\n}\n","import { curry } from '@blakek/curry';\nimport { parse } from 'pathington';\nimport { isObject } from './is-object';\n\nexport type Path = Array<number | string> | string;\n\nconst NotFound = Symbol('curriable placeholder');\n\nexport function traverseObject(object: any, path: string[]): any {\n  // If the path has been exhausted, return the current object\n  if (path.length === 0) {\n    return object;\n  }\n\n  // If the value could not be found, return `defaultValue`\n  if (!isObject(object)) {\n    return NotFound;\n  }\n\n  const [key, ...keys] = path;\n\n  // Search deeper in the object\n  if (key in object) {\n    return traverseObject(object[key], keys);\n  }\n\n  // The key was not found in the object.\n  return NotFound;\n}\n\nfunction _getOr(defaultValue: any, path: Path, object: any): any {\n  if (path === undefined) return object;\n\n  const value = traverseObject(object, parse(path));\n\n  if (value === NotFound || value === undefined) {\n    return defaultValue;\n  }\n\n  return value;\n}\n\nconst _get = (path: Path, object: any): any => _getOr(undefined, path, object);\n\nfunction _has(path: Path, object: any): boolean {\n  const value = traverseObject(object, parse(path));\n  return value !== NotFound;\n}\n\nfunction _remove(path: Path, object: any): any {\n  if (path === undefined) return object;\n  const parsedPath = parse(path);\n\n  const referencePath = parsedPath.slice(0, -1);\n  const finalPath = parsedPath[parsedPath.length - 1];\n  const reference = traverseObject(object, parse(referencePath));\n\n  if (!reference) return object;\n\n  delete reference[finalPath];\n\n  return object;\n}\n\nfunction _pluck(properties: Path[], object: any): any {\n  return properties.reduce(\n    (subset, property) => _set(_get(property, object), property, subset),\n    {}\n  );\n}\n\nfunction _set(value: any, path: Path, object: any): any {\n  const parsedPath = parse(path);\n  let reference = object;\n\n  parsedPath.forEach((key, index) => {\n    if (index === parsedPath.length - 1) {\n      reference[key] = value;\n      return;\n    }\n\n    if (!isObject(reference[key])) {\n      reference[key] = {};\n    }\n\n    reference = reference[key];\n  });\n\n  return object;\n}\n\nexport const get = curry(_get);\nexport const getOr = curry(_getOr);\nexport const has = curry(_has);\nexport const pluck = curry(_pluck);\nexport const remove = curry(_remove);\nexport const set = curry(_set);\n"],"names":["curry","fn","arity","length","curried","args","slice","newArgs","CACHE","clear","results","size","DOTTY_WITH_BRACKETS_SYNTAX","NUMBER","QUOTED_KEY","map","array","mapped","index","getNormalizedParseKey","key","cleanKey","test","isQuotedKey","isNumericKey","isArray","Array","parse","path","match","parseStringPath","normalizedParseKey","isObject","object","type","NotFound","Symbol","traverseObject","keys","_getOr","defaultValue","undefined","value","_get","_set","parsedPath","reference","forEach","get","getOr","has","pluck","properties","reduce","subset","property","remove","referencePath","finalPath","set"],"mappings":"kMAAA,SAASA,EAAMC,EAAIC,mBAAAA,IAAAA,EAAQD,EAAGE,QACrB,SAASC,+BAAWC,2BAAAA,yBACrBA,EAAKF,QAAUD,EACVD,eAAMI,EAAKC,MAAM,EAAGJ,IAGtB,sCAAIK,2BAAAA,yBAAYH,eAAWC,SAASE,MCCxC,IAAIC,EAAQ,CACjBC,MAAO,WACLD,EAAME,QAAU,GAChBF,EAAMG,KAAO,GAEfD,QAAS,GACTC,KAAM,GAMGC,EAA6B,oCAU7BC,EAAS,SAKTC,EAAa,4BCKbC,EAAM,SAAaC,EAAOf,WAC/BE,EAASa,EAAMb,OACfc,EAAS,GAEJC,EAAQ,EAAGA,EAAQf,EAAQe,IAClCD,EAAOC,GAASjB,EAAGe,EAAME,WAGpBD,GAsDEE,EAAwB,SAA+BC,OAC5DC,EA7EmB,SAAqBD,UACrCN,EAAWQ,KAAKF,GA4ERG,CAAYH,GAAOA,EAAId,MAAM,EAAGc,EAAIjB,OAAS,GAAKiB,SA1FzC,SAAsBA,YACpCA,IAAOA,EAAIjB,SAAWU,EAAOS,KAAKF,GA0FrCI,CAAaH,IAAaA,EAAWA,GCnG1CI,EAAUC,MAAMD,QAsCTE,EAAQ,SAAeC,MACZ,iBAATA,SDwEgB,SAAyBA,UAChDpB,EAAME,QAAQkB,KAIdpB,EAAMG,KDhGgB,KCiGxBH,EAAMC,QAGRD,EAAME,QAAQkB,GAAQA,EAAOb,EAAIa,EAAKC,MAAMjB,GAA6BO,GAAyB,CAACS,GACnGpB,EAAMG,QARGH,EAAME,QAAQkB,GCzEdE,CAAgBF,MAGrBH,EAAQG,UACHb,EAAIa,EAAMT,OAGfY,EAAqBZ,EAAsBS,SACxC,CAA+B,iBAAvBG,EAAkCA,EAAqB,GAAKA,ICpDtE,SAASC,EAASC,MACR,OAAXA,EAAiB,OAAO,MAEtBC,SAAcD,QACJ,WAATC,GAA8B,aAATA,ECE9B,IAAMC,EAAWC,OAAO,yBAEjB,SAASC,EAAeJ,EAAaL,MAEtB,IAAhBA,EAAKzB,cACA8B,MAIJD,EAASC,UACLE,MAGFf,EAAgBQ,KAARU,EAAQV,kBAGnBR,KAAOa,EACFI,EAAeJ,EAAOb,GAAMkB,GAI9BH,EAGT,SAASI,EAAOC,EAAmBZ,EAAYK,WAChCQ,IAATb,EAAoB,OAAOK,MAEzBS,EAAQL,EAAeJ,EAAQN,EAAMC,WAEvCc,IAAUP,QAAsBM,IAAVC,EACjBF,EAGFE,EAGT,IAAMC,EAAO,SAACf,EAAYK,UAAqBM,OAAOE,EAAWb,EAAMK,IA6BvE,SAASW,EAAKF,EAAYd,EAAYK,OAC9BY,EAAalB,EAAMC,GACrBkB,EAAYb,SAEhBY,EAAWE,SAAQ,SAAC3B,EAAKF,GACnBA,IAAU2B,EAAW1C,OAAS,GAK7B6B,EAASc,EAAU1B,MACtB0B,EAAU1B,GAAO,IAGnB0B,EAAYA,EAAU1B,IARpB0B,EAAU1B,GAAOsB,KAWdT,MAGIe,EAAMhD,EAAM2C,GACZM,EAAQjD,EAAMuC,GACdW,EAAMlD,GAjDnB,SAAc4B,EAAYK,UACVI,EAAeJ,EAAQN,EAAMC,MAC1BO,KAgDNgB,EAAQnD,GA9BrB,SAAgBoD,EAAoBnB,UAC3BmB,EAAWC,QAChB,SAACC,EAAQC,UAAaX,EAAKD,EAAKY,EAAUtB,GAASsB,EAAUD,KAC7D,OA4BSE,EAASxD,GA9CtB,SAAiB4B,EAAYK,WACdQ,IAATb,EAAoB,OAAOK,MACzBY,EAAalB,EAAMC,GAEnB6B,EAAgBZ,EAAWvC,MAAM,GAAI,GACrCoD,EAAYb,EAAWA,EAAW1C,OAAS,GAC3C2C,EAAYT,EAAeJ,EAAQN,EAAM8B,WAE1CX,UAEEA,EAAUY,GAEVzB,GAJgBA,KAuCZ0B,EAAM3D,EAAM4C"}